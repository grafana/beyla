name: Port to Upstream OTel eBPF Instrumentation

on:
  pull_request:
    types: [opened, synchronize, labeled, closed]

permissions:
  contents: read
  id-token: write
  pull-requests: write

jobs:
  port-to-upstream:
    if: |
      github.event_name == 'pull_request' && github.event.action != 'closed'
    runs-on: ubuntu-latest
    steps:
      - name: Get secrets from Vault
        id: get-secrets
        uses: grafana/shared-workflows/actions/get-vault-secrets@main
        with:
          repo_secrets: |
            GITHUB_APP_ID=github-app:app-id
            GITHUB_APP_INSTALLATION_ID=github-app:app-installation-id
            GITHUB_APP_PRIVATE_KEY=github-app:private-key
      - name: Checkout Beyla
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          
      - name: Generate App Token
        uses: actions/create-github-app-token@v1
        id: app-token
        with:
          app-id: ${{ env.GITHUB_APP_ID }}
          private-key: ${{ env.GITHUB_APP_PRIVATE_KEY }}
          installation-id: ${{ env.GITHUB_APP_INSTALLATION_ID }}
          owner: grafana
          repositories: "opentelemetry-ebpf-instrumentation"
          permission-contents: write
          
      - name: Configure Git
        run: |
          git config --global user.name "GitHub Actions Bot"
          git config --global user.email "actions@github.com"

      - name: Checkout target repository
        uses: actions/checkout@v4
        with:
          repository: grafana/opentelemetry-ebpf-instrumentation
          token: ${{ steps.app-token.outputs.token }}
          path: opentelemetry-ebpf-instrumentation          
          
      - name: Port changes and prepare PR
        env:
          GH_TOKEN: ${{ steps.app-token.outputs.token }}
          TARGET_PR_NUMBER: "1904"  # Hardcoded target PR number
          PR_NUMBER: ${{ github.event.pull_request.number }}
          PR_URL: ${{ github.event.pull_request.html_url }}
          PR_TITLE: ${{ github.event.pull_request.title }}
          BRANCH_NAME: port/1904-to-upstream
        run: |
          # Fetch the target PR information
          echo "Fetching information for PR #1904"
          TARGET_PR_INFO=$(gh pr view 1904 --repo grafana/beyla --json title,url,baseRefName,headRefName,headRepositoryOwner,headRepository)
          TARGET_PR_TITLE=$(echo "$TARGET_PR_INFO" | jq -r '.title')
          TARGET_PR_URL=$(echo "$TARGET_PR_INFO" | jq -r '.url')
          TARGET_PR_BASE_BRANCH=$(echo "$TARGET_PR_INFO" | jq -r '.baseRefName')
          TARGET_PR_HEAD_BRANCH=$(echo "$TARGET_PR_INFO" | jq -r '.headRefName')
          TARGET_PR_HEAD_OWNER=$(echo "$TARGET_PR_INFO" | jq -r '.headRepositoryOwner.login')
          TARGET_PR_HEAD_REPO=$(echo "$TARGET_PR_INFO" | jq -r '.headRepository.name')
          
          echo "Target PR Title: $TARGET_PR_TITLE"
          echo "Target PR URL: $TARGET_PR_URL"
          
          # Fetch the PR branch
          git fetch origin pull/1904/head:pr-1904
          git checkout pr-1904
          
          # Get the base and head SHAs
          TARGET_BASE_SHA=$(git merge-base origin/$TARGET_PR_BASE_BRANCH pr-1904)
          TARGET_HEAD_SHA=$(git rev-parse HEAD)
          
          echo "Target PR Base SHA: $TARGET_BASE_SHA"
          echo "Target PR Head SHA: $TARGET_HEAD_SHA"
          
          # Get the list of changed files in the target PR
          CHANGED_FILES=$(git diff --name-only ${TARGET_BASE_SHA} ${TARGET_HEAD_SHA})
          
          # Exit if no files have changed
          if [ -z "${CHANGED_FILES}" ]; then
            echo "No files have changed in PR #1904. Nothing to port."
            exit 0
          fi
          
          # Print the list of changed files
          echo "Files changed in PR #1904:"
          echo "${CHANGED_FILES}"
          
          # Navigate to the target repository
          cd opentelemetry-ebpf-instrumentation
          
          # Configure git locally
          git config --local user.email bot@grafana.com
          git config --local user.name grafanabot
          
          # Create a new branch
          git checkout -b ${BRANCH_NAME}
          
          # Go back to the beyla repository
          cd ..
          
          # Create a patches directory
          mkdir -p patches
          
          # Generate specific patches for each changed file
          COPY_ERRORS=""
          APPLIED_CHANGES=0
          
          for file in ${CHANGED_FILES}; do
            # Skip vendor files
            if [[ $file == vendor/* ]]; then
              echo "Skipping vendor file: $file"
              COPY_ERRORS+="- Skipped vendor file: $file\n"
              continue
            fi
            
            # Check if the file exists in the target repository
            TARGET_FILE="opentelemetry-ebpf-instrumentation/$file"
            
            # Create the patch for this specific file
            echo "Creating patch for $file"
            # Use a more reliable patch format with -p1 in mind
            git diff --no-prefix -U10 ${TARGET_BASE_SHA} ${TARGET_HEAD_SHA} -- "$file" > "patches/${file//\//_}.patch"
            
            # If the target file doesn't exist, add to errors and continue
            if [[ ! -f "$TARGET_FILE" ]]; then
              echo "Target file doesn't exist: $TARGET_FILE"
              COPY_ERRORS+="- Target file doesn't exist: $file\n"
              
              # For non-vendor files that don't exist in target repo, save content for manual review
              if [[ $file != vendor/* ]]; then
                mkdir -p "missing_files/$(dirname "$file")"
                cp "$file" "missing_files/$file"
                echo "Saved content to missing_files/$file for manual review"
              fi
              continue
            fi
            
            # For go.mod and go.sum files, use a special approach
            if [[ $file == "go.mod" || $file == "go.sum" ]]; then
              echo "Special handling for $file"
              
              # Extract version changes for go.mod
              if [[ $file == "go.mod" ]]; then
                # Extract version number changes only
                grep "go\." "patches/${file//\//_}.patch" | grep -v "//go:" > "patches/${file//\//_}.versions"
                echo "Extracted version changes to patches/${file//\//_}.versions"
                
                # Save these for manual review in PR description
                VERSION_CHANGES=$(cat "patches/${file//\//_}.versions")
                COPY_ERRORS+="- $file version changes (for manual application):\n$VERSION_CHANGES\n"
              fi
              
              # Continue without trying to apply these patches automatically
              continue
            }
            
            # Navigate to the target repository to apply patch
            cd opentelemetry-ebpf-instrumentation
            
            # Try with different patch options
            patch_applied=false
            
            # Try first with git apply with increasing fuzz factor
            for fuzz in 0 3 5; do
              if git apply --check --ignore-whitespace --reject --fuzz=$fuzz "../patches/${file//\//_}.patch" 2>/tmp/patch_error; then
                echo "Applying patch to $file with git apply (fuzz=$fuzz)"
                git apply --ignore-whitespace --fuzz=$fuzz "../patches/${file//\//_}.patch"
                patch_applied=true
                APPLIED_CHANGES=$((APPLIED_CHANGES + 1))
                break
              fi
            done
            
            # If git apply didn't work, try patch command with different options
            if [ "$patch_applied" = false ]; then
              echo "Git apply failed, trying patch command..."
              if patch -p0 --forward --ignore-whitespace --fuzz=3 < "../patches/${file//\//_}.patch" 2>/tmp/patch_error; then
                echo "Applied patch to $file with patch command"
                patch_applied=true
                APPLIED_CHANGES=$((APPLIED_CHANGES + 1))
              else
                ERROR_MSG=$(cat /tmp/patch_error)
                echo "Failed to apply patch to $file: $ERROR_MSG"
                
                # Extract the hunks that succeeded for the report
                SUCCEEDED_HUNKS=$(grep "Hunk #.*succeeded" /tmp/patch_error | wc -l)
                TOTAL_HUNKS=$(grep "Hunk #" /tmp/patch_error | wc -l)
                
                COPY_ERRORS+="- $file: Applied $SUCCEEDED_HUNKS/$TOTAL_HUNKS hunks. Manual attention needed.\n"
                
                # Try to apply what we can with -N (ignore failures) for partial progress
                patch -p0 --forward --ignore-whitespace -N < "../patches/${file//\//_}.patch" 2>/dev/null || true
              fi
            fi
            
            # Go back to the beyla repository
            cd ..
          done
          
          # If we have missing files that need to be reviewed and potentially added
          if [ -d "missing_files" ]; then
            echo "The following new files from PR #1904 don't exist in the target repository:"
            find missing_files -type f | sort
            
            # Create a tar file of missing files for easy download from artifacts
            tar -czf missing_files.tar.gz missing_files/
          fi
          
          # Go to the target repository
          cd opentelemetry-ebpf-instrumentation
          
          # Check if there are any changes
          if git diff --quiet; then
            echo "No relevant changes to commit"
            exit 0
          fi
          
          # Add and commit the changes
          git add .
          
          # Create commit message with errors if any
          COMMIT_MSG="[port] #1904: ${TARGET_PR_TITLE}
          
          Automated port of #1904 from grafana/beyla.
          Original PR: ${TARGET_PR_URL}"
          
          if [[ ! -z "$COPY_ERRORS" ]]; then
            COMMIT_MSG+="
          
          NOTE: Some files couldn't be copied automatically and may need manual attention:
          ${COPY_ERRORS}"
          fi
          
          git diff --staged --quiet || git commit -m "$COMMIT_MSG"
          
          # Check if we have changes to push
          if git diff --quiet HEAD HEAD~1 2>/dev/null; then
            echo "No changes to push"
            exit 0
          fi
          
          # Push changes to the fork repository
          git push origin "refs/heads/${BRANCH_NAME}" --force
          
          # Output summary information for debugging
          echo "================ PORTING SUMMARY ================"
          echo "PR #1904: ${TARGET_PR_TITLE}"
          echo "PR URL: ${TARGET_PR_URL}"
          echo "Total files changed in PR: $(echo "${CHANGED_FILES}" | wc -l)"
          echo "Non-vendor files changed: $(echo "${CHANGED_FILES}" | grep -v "^vendor/" | wc -l)"
          echo "Successfully applied changes: ${APPLIED_CHANGES}"
          
          if [[ ! -z "$COPY_ERRORS" ]]; then
            echo -e "\nIssues encountered:"
            echo -e "${COPY_ERRORS}"
          fi
          
          # If we need to debug specific files being processed
          echo -e "\nNon-vendor files that weren't fully applied:"
          for file in ${CHANGED_FILES}; do
            if [[ $file != vendor/* ]]; then
              # Check if this non-vendor file was successfully patched
              FILE_PATCH="../patches/${file//\//_}.patch"
              if [ -f "$FILE_PATCH" ] && [ -s "$FILE_PATCH" ]; then
                # Special handling for go.mod and go.sum
                if [[ $file == "go.mod" || $file == "go.sum" ]]; then
                  echo "- $file (requires manual application)"
                elif [[ ! -f "$file" ]]; then
                  echo "- $file (target file doesn't exist)"
                elif ! grep -q "Hunk #.*succeeded" /tmp/patch_error 2>/dev/null; then
                  # If we have zero succeeded hunks, it wasn't applied at all
                  echo "- $file (patch couldn't be applied at all)"
                elif grep -q "Hunk #.*FAILED" /tmp/patch_error 2>/dev/null; then
                  # If we have some failed hunks, it was partially applied
                  echo "- $file (patch was partially applied)"
                fi
              fi
            fi
          done
          echo "================================================="
          
          # PR creation is intentionally kept commented out
          # PR_URL=$(gh pr create \
          #   --title "[port] #1904: ${TARGET_PR_TITLE}" \
          #   --body "Automated port of #1904 from grafana/beyla.
          
          #   Original PR: ${TARGET_PR_URL}" \
          #   --repo open-telemetry/opentelemetry-ebpf-instrumentation \
          #   --head grafana:${BRANCH_NAME} \
          #   --base main \
          #   --draft)
          
          # echo "upstream_pr_url=${PR_URL}" >> $GITHUB_OUTPUT
          # echo "upstream_pr_number=$(basename ${PR_URL})" >> $GITHUB_OUTPUT
