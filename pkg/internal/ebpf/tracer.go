//go:build linux

package ebpf

import (
	"context"
	"errors"
	"fmt"
	"io"
	"log/slog"
	"os"
	"reflect"
	"regexp"
	"slices"
	"strings"

	"github.com/cilium/ebpf"
	"github.com/cilium/ebpf/link"
	"golang.org/x/sys/unix"

	ebpfcommon "github.com/grafana/beyla/pkg/internal/ebpf/common"
	"github.com/grafana/beyla/pkg/internal/ebpf/services"
	"github.com/grafana/beyla/pkg/internal/exec"
	"github.com/grafana/beyla/pkg/internal/goexec"
	"github.com/grafana/beyla/pkg/internal/pipe"
	"github.com/grafana/beyla/pkg/internal/request"
	"github.com/grafana/beyla/pkg/internal/svc"
)

func ptlog() *slog.Logger { return slog.With("component", "ebpf.ProcessTracer") }

// Tracer is an individual eBPF program (e.g. the net/http or the grpc tracers)
type Tracer interface {
	// Load the bpf object that is generated by the bpf2go compiler
	Load() (*ebpf.CollectionSpec, error)
	// Constants returns a map of constants to be overriden into the eBPF program.
	// The key is the constant name and the value is the value to overwrite.
	Constants(*exec.FileInfo, *goexec.Offsets) map[string]any
	// BpfObjects that are created by the bpf2go compiler
	BpfObjects() any
	// GoProbes returns a map with the name of Go functions that need to be inspected
	// in the executable, as well as the eBPF programs that optionally need to be
	// inserted as the Go function start and end probes
	GoProbes() map[string]ebpfcommon.FunctionPrograms
	// KProbes returns a map with the name of the kernel probes that need to be
	// tapped into. Start matches kprobe, End matches kretprobe
	KProbes() map[string]ebpfcommon.FunctionPrograms
	// UProbes returns a map with the module name mapping to the uprobes that need to be
	// tapped into. Start matches uprobe, End matches uretprobe
	UProbes() map[string]map[string]ebpfcommon.FunctionPrograms
	// SocketFilters  returns a list of programs that need to be loaded as a
	// generic eBPF socket filter
	SocketFilters() []*ebpf.Program
	// Run will do the action of listening for eBPF traces and forward them
	// periodically to the output channel.
	// It optionally receives the service svc.ID, to
	// populate each forwarded span with its value. But some
	// tracers might ignore it (e.g. system-wide HTTP filter will directly set the
	// executable name of each request).
	Run(context.Context, chan<- []request.Span, svc.ID)
	// AddCloser adds io.Closer instances that need to be invoked when the
	// Run function ends.
	AddCloser(c ...io.Closer)
}

// ProcessTracer instruments an executable with eBPF and provides the eBPF readers
// that will forward the traces to later stages in the pipeline
// TODO: split in two, the instrumenter and the reader
type ProcessTracer struct {
	log      *slog.Logger
	programs []Tracer
	ELFInfo  *exec.FileInfo
	goffsets *goexec.Offsets
	exe      *link.Executable
	pinPath  string

	systemWide bool
}

func (pt *ProcessTracer) Run(ctx context.Context, out chan<- []request.Span) {
	if err := pt.init(); err != nil {
		pt.log.Error("cant start process tracer. Stopping", "error", err)
	}
	pt.log.Debug("starting process tracer")
	// Searches for traceable functions
	trcrs, err := pt.tracers()
	if err != nil {
		pt.log.Error("couldn't trace process. Stopping process tracer", "error", err)
		return
	}

	service := pt.ELFInfo.Service
	// If the user does not override the service name via configuration
	// the service name is the name of the found executable
	// Unless the case of system-wide tracing, where the name of the
	// executable will be dynamically set for each traced http request call.
	if service.Name == "" && !pt.systemWide {
		service.Name = pt.ELFInfo.ExecutableName()
	}
	// run each tracer program
	for _, t := range trcrs {
		go t.Run(ctx, out, service)
	}
	go func() {
		<-ctx.Done()
		pt.close()
	}()
}

func (pt *ProcessTracer) init() error {
	pt.log = ptlog().With("path", pt.ELFInfo.CmdExePath, "pid", pt.ELFInfo.Pid)
	if err := pt.mountBpfPinPath(); err != nil {
		return fmt.Errorf("can't mount BPF filesystem: %w", err)
	}
	return nil
}

func (pt *ProcessTracer) close() {
	pt.unmountBpfPinPath()
}

func (pt *ProcessTracer) mountBpfPinPath() error {
	pt.log.Debug("mounting BPF map pinning path")
	if _, err := os.Stat(pt.pinPath); err != nil {
		if !os.IsNotExist(err) {
			return fmt.Errorf("accessing %s stat: %w", pt.pinPath, err)
		}
		pt.log.Debug("BPF map pinning path does not exist. Creating before mounting")
		if err := os.MkdirAll(pt.pinPath, 0700); err != nil {
			return fmt.Errorf("creating directory %s: %w", pt.pinPath, err)
		}
	}

	return bpfMount(pt.pinPath)
}

func (pt *ProcessTracer) unmountBpfPinPath() {
	if err := unix.Unmount(pt.pinPath, unix.MNT_FORCE); err != nil {
		pt.log.Warn("can't unmount pinned root. Try unmounting and removing it manually", err)
		return
	}
	pt.log.Debug("unmounted bpf file system")
	if err := os.RemoveAll(pt.pinPath); err != nil {
		pt.log.Warn("can't remove pinned root. Try removing it manually", err)
	} else {
		pt.log.Debug("removed pin path")
	}
}

// tracers returns Tracer implementer for each discovered eBPF traceable source: GRPC, HTTP...
func (pt *ProcessTracer) tracers() ([]Tracer, error) {
	var log = ptlog()

	// tracerFuncs contains the eBPF programs (HTTP, GRPC tracers...)
	var tracers []Tracer

	for _, p := range pt.programs {
		plog := log.With("program", reflect.TypeOf(p))
		plog.Debug("loading eBPF program")
		spec, err := p.Load()
		if err != nil {
			return nil, fmt.Errorf("loading eBPF program: %w", err)
		}
		if err := spec.RewriteConstants(p.Constants(pt.ELFInfo, pt.goffsets)); err != nil {
			return nil, fmt.Errorf("rewriting BPF constants definition: %w", err)
		}
		if err := spec.LoadAndAssign(p.BpfObjects(), &ebpf.CollectionOptions{
			Maps: ebpf.MapOptions{
				PinPath: pt.pinPath,
			}}); err != nil {
			printVerifierErrorInfo(err)
			return nil, fmt.Errorf("loading and assigning BPF objects: %w", err)
		}
		i := instrumenter{
			exe:     pt.exe,
			offsets: pt.goffsets,
		}

		//Go style Uprobes
		if err := i.goprobes(p); err != nil {
			printVerifierErrorInfo(err)
			return nil, err
		}

		//Kprobes to be used for native instrumentation points
		if err := i.kprobes(p); err != nil {
			printVerifierErrorInfo(err)
			return nil, err
		}

		//Uprobes to be used for native module instrumentation points
		if err := i.uprobes(pt.ELFInfo.Pid, p); err != nil {
			printVerifierErrorInfo(err)
			return nil, err
		}

		//Sock filters support
		if err := i.sockfilters(p); err != nil {
			printVerifierErrorInfo(err)
			return nil, err
		}

		tracers = append(tracers, p)
	}

	return tracers, nil
}

// filterNotFoundPrograms will filter these programs whose required functions (as
// returned in the Offsets method) haven't been found in the offsets
func filterNotFoundPrograms(programs []Tracer, offsets *goexec.Offsets) []Tracer {
	var filtered []Tracer
	funcs := offsets.Funcs
programs:
	for _, p := range programs {
		for fn, fp := range p.GoProbes() {
			if !fp.Required {
				continue
			}
			if _, ok := funcs[fn]; !ok {
				continue programs
			}
		}
		filtered = append(filtered, p)
	}
	return filtered
}

func isGoProxy(offsets *goexec.Offsets) bool {
	for f := range offsets.Funcs {
		// if we find anything of interest other than the Go runtime, we consider this a valid application
		if !strings.HasPrefix(f, "runtime.") {
			return false
		}
	}

	return true
}

type instrumentableExec struct {
	fileInfo *exec.FileInfo
	offsets  *goexec.Offsets
}

type executablesInspector struct {
	cfg           *pipe.Config
	functions     []string
	pidMap        map[int32]*exec.FileInfo
	fallBackInfos []*exec.FileInfo
	goProxies     []*exec.FileInfo
}

func inspect(ctx context.Context, cfg *pipe.Config, functions []string) ([]instrumentableExec, error) {
	ei := executablesInspector{
		cfg:       cfg,
		functions: functions,
		pidMap:    map[int32]*exec.FileInfo{},
	}
	return ei.doInspection(ctx)
}

func (ei *executablesInspector) doInspection(ctx context.Context) ([]instrumentableExec, error) {
	elfs, err := exec.FindExecELFs(ctx, findingCriteria(ei.cfg))
	defer func() {
		for _, e := range elfs {
			e.ELF.Close()
		}
	}()
	if err != nil {
		return nil, fmt.Errorf("looking for executable ELFs: %w", err)
	}
	var out []instrumentableExec
	for i := range elfs {
		if inst, ok := ei.asInstrumentable(&elfs[i]); ok {
			out = append(out, inst)
		}
	}
	ptlog().Debug("found instrumentable processes", "len", len(out))
	return out, nil
}

func (ei *executablesInspector) asInstrumentable(execElf *exec.FileInfo) (instrumentableExec, bool) {
	log := ptlog().With("pid", execElf.Pid, "comm", execElf.CmdExePath)
	log.Debug("getting instrumentable information")
	// look for suitable Go application first
	offsets, ok := inspectOffsets(ei.cfg, execElf, ei.functions)
	if !ok {
		ei.fallBackInfos = append(ei.fallBackInfos, execElf)
		ei.pidMap[execElf.Pid] = execElf
		log.Debug("adding fall-back generic executable")
		return instrumentableExec{}, false
	}

	// we found go offsets, let's see if this application is not a proxy
	if !isGoProxy(offsets) {
		return instrumentableExec{fileInfo: execElf, offsets: offsets}, true
	}

	log.Debug("ignoring Go proxy for now")
	ei.goProxies = append(ei.goProxies, execElf)
	ei.pidMap[execElf.Pid] = execElf

	if len(ei.goProxies) != 0 {
		execElf = ei.goProxies[len(ei.goProxies)-1]
	} else if len(ei.fallBackInfos) != 0 {
		execElf = ei.fallBackInfos[len(ei.fallBackInfos)-1]
	} else {
		log.Warn("looking for executable ELF, no suitable processes found. Ignoring")
		return instrumentableExec{}, false
	}

	// check if the executable is a subprocess of another we have found, f so use the parent
	if parentElf, ok := ei.pidMap[execElf.Ppid]; ok {
		execElf = parentElf
	}

	log.Info("Go HTTP/gRPC support not detected. Using only generic instrumentation.")
	log.Info("instrumented", "comm", execElf.CmdExePath, "pid", execElf.Pid)

	return instrumentableExec{fileInfo: execElf, offsets: offsets}, true
}

func inspectOffsets(cfg *pipe.Config, execElf *exec.FileInfo, functions []string) (*goexec.Offsets, bool) {
	if !cfg.SystemWide {
		log := ptlog()
		if cfg.SkipGoSpecificTracers {
			log.Debug("skipping inspection for Go functions", "pid", execElf.Pid, "comm", execElf.CmdExePath)
		} else {
			log.Debug("inspecting", "pid", execElf.Pid, "comm", execElf.CmdExePath)
			if offsets, err := goexec.InspectOffsets(execElf, functions); err != nil {
				log.Debug("couldn't find go specific tracers", "error", err)
			} else {
				return offsets, true
			}
		}
	}
	return nil, false
}

func findingCriteria(cfg *pipe.Config) services.DefinitionCriteria {
	if cfg.SystemWide {
		// will return all the executables in the system
		return services.DefinitionCriteria{
			services.Attributes{
				Namespace: cfg.ServiceNamespace,
				Path:      services.NewPathRegexp(regexp.MustCompile(".")),
			},
		}
	}
	finderCriteria := cfg.Services
	// Merge the old, individual single-service selector,
	// with the new, map-based multi-services selector.
	if cfg.Exec.IsSet() || cfg.Port.Len() > 0 {
		finderCriteria = slices.Clone(cfg.Services)
		finderCriteria = append(finderCriteria, services.Attributes{
			Name:      cfg.ServiceName,
			Namespace: cfg.ServiceNamespace,
			Path:      cfg.Exec,
			OpenPorts: cfg.Port,
		})
	}
	return finderCriteria
}

func printVerifierErrorInfo(err error) {
	var ve *ebpf.VerifierError
	if errors.As(err, &ve) {
		_, _ = fmt.Fprintf(os.Stderr, "Error Log:\n %v\n", strings.Join(ve.Log, "\n"))
	}
}

func bpfMount(pinPath string) error {
	return unix.Mount(pinPath, pinPath, "bpf", 0, "")
}
